Here are the generated code files based on the original files, implementing the new algorithm for detecting a cycle in a linked list:

<lib.c>
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

struct Linked_List {
    int data;
    struct Linked_List* next;
};

// Function prototypes
extern struct Linked_List* setup_question();
extern void print_LinkedList(struct Linked_List* head);


struct Linked_List* buildLinkedList(int arr[], int n, int pos){
    
    struct Linked_List* head = (struct Linked_List* ) malloc(sizeof(struct Linked_List));

    if(n == 0){
        return NULL; 
    }

    struct Linked_List* dummy_head = head; 
    
    for(int i = 0; i < n ; i++){
        dummy_head->data = arr[i]; 
        if (i != n-1){
            dummy_head->next = (struct Linked_List* ) malloc(sizeof(struct Linked_List));
            dummy_head = dummy_head->next; 
        }
    }

    if (pos != -1) {
        struct Linked_List* tail = head;
        while (tail->next != NULL) {
            tail = tail->next;
        }
        struct Linked_List* node = head;
        for (int i = 0; i < pos; i++) {
            node = node->next;
        }
        tail->next = node;
    }

    return head; 

}

void print_LinkedList(struct Linked_List* head){

    if(head == NULL){
        printf(""); 
    }

    while(head){
        printf("%d", head->data); 
        if(head->next){    
            printf(" "); 
        }
        head = head->next;
    }
    printf("\n"); 
}

struct Linked_List* setup_question(){
    int n, pos;
    
    // Input the number of elements and cycle position
    scanf("%d %d", &n, &pos);

    // Create an array to store the node values
    int nodes[n];

    // Input the values into the array
    for (int i = 0; i < n; i++) {
        scanf("%d", &nodes[i]);
    }

    // Build the linked list
    struct Linked_List* head =  buildLinkedList(nodes, n, pos); 

    return head;
}
</lib.c>

<main.c>
#include "../inc/util.h"

bool detect_cycle(struct Linked_List* head) {
    // Write your code here
    
}

int main(){

    // Setup the linked list
    struct Linked_List* head = setup_question();
    
    // User function to detect cycle in the linked list
    bool has_cycle = detect_cycle(head); 

    // Print the result
    printf(has_cycle ? "true\n" : "false\n");
    
    return 0;
}
</main.c>

<main_dev.c>
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

struct Linked_List {
    int data;
    struct Linked_List* next;
};

// Function prototypes
extern struct Linked_List* setup_question();
extern void print_LinkedList(struct Linked_List* head);

bool detect_cycle(struct Linked_List* head) {
    // Write your code here
    struct Linked_List* slow = head;  // Slow pointer
    struct Linked_List* fast = head;  // Fast pointer

    while (fast != NULL && fast->next != NULL) {
        slow = slow->next;
        fast = fast->next->next;
        if (slow == fast) {
            return true;  // Cycle detected
        }
    }

    return false;  // No cycle found
}

int main(){

    // Setup the linked list
    struct Linked_List* head = setup_question();
    
    // User function to detect cycle in the linked list
    bool has_cycle = detect_cycle(head); 

    // Print the result
    printf(has_cycle ? "true\n" : "false\n");
    
    return 0;
}
</main_dev.c>

<util.h>
#ifndef UTIL_H
#define UTIL_H

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

struct Linked_List {
    int data;
    struct Linked_List* next;
};

// Function prototypes
extern struct Linked_List* setup_question();
extern void print_LinkedList(struct Linked_List* head);

#endif // UTIL_H
</util.h>

<lib.cpp>
#include <iostream>
#include <vector>

class LinkedList {
public:
    int data;
    LinkedList* next;

    LinkedList(int val) : data(val), next(nullptr) {}
};

// Function declarations

LinkedList* setup_question();
void print_LinkedList(LinkedList* head);



// Function to build a linked list from an array
LinkedList* buildLinkedList(int arr[], int n, int pos) {
    if (n == 0) {
        return nullptr;
    }

    LinkedList* head = new LinkedList(arr[0]);
    LinkedList* dummy_head = head;

    for (int i = 1; i < n; ++i) {
        dummy_head->next = new LinkedList(arr[i]);
        dummy_head = dummy_head->next;
    }

    if (pos != -1) {
        LinkedList* tail = head;
        while (tail->next != nullptr) {
            tail = tail->next;
        }
        LinkedList* node = head;
        for (int i = 0; i < pos; ++i) {
            node = node->next;
        }
        tail->next = node;
    }

    return head;
}

// Function to print the linked list
void print_LinkedList(LinkedList* head) {
    if (!head) {
        return;
    }

    while (head) {
        std::cout << head->data;
        if (head->next) {
            std::cout << " ";
        }
        head = head->next;
    }
    std::cout << std::endl;
}

LinkedList* setup_question() {
    
    // Input the number of elements and cycle position
    int n, pos;
    std::cin >> n >> pos;

    // Dynamically allocate an array to store the node values
    int* nodes = new int[n];

    // Input the values into the array
    for (int i = 0; i < n; i++) {
        std::cin >> nodes[i];
    }

    // Build the linked list
    LinkedList* head = buildLinkedList(nodes, n, pos);

    return head;
}
</lib.cpp>

<main.cpp>
#include "../inc/util.hpp"
#include <vector>
#include <iostream>

bool detect_cycle(LinkedList* head) {
    // Write your code here
    
}

int main() {
    
    // Setup the linked list
    LinkedList* head = setup_question();

    // Call the user function to detect cycle in the linked list
    bool has_cycle = detect_cycle(head);

    // Print the result
    std::cout << (has_cycle ? "true" : "false") << std::endl;

    return 0;
}
</main.cpp>

<main_dev.cpp>
#include <vector>
#include <iostream>


class LinkedList {
public:
    int data;
    LinkedList* next;

    LinkedList(int val) : data(val), next(nullptr) {}
};

// Function declarations

LinkedList* setup_question();
void print_LinkedList(LinkedList* head);

bool detect_cycle(LinkedList* head) {
    // Write your code here
    LinkedList* slow = head;  // Slow pointer
    LinkedList* fast = head;  // Fast pointer

    while (fast != nullptr && fast->next != nullptr) {
        slow = slow->next;
        fast = fast->next->next;
        if (slow == fast) {
            return true;  // Cycle detected
        }
    }

    return false;  // No cycle found
}

int main() {
    
    // Setup the linked list
    LinkedList* head = setup_question();

    // Call the user function to detect cycle in the linked list
    bool has_cycle = detect_cycle(head);

    // Print the result
    std::cout << (has_cycle ? "true" : "false") << std::endl;

    return 0;
}
</main_dev.cpp>

<util.hpp>
#ifndef UTIL_H
#define UTIL_H

#include <iostream>
#include <vector>

class LinkedList {
public:
    int data;
    LinkedList* next;

    LinkedList(int val) : data(val), next(nullptr) {}
};

// Function declarations

LinkedList* setup_question();
void print_LinkedList(LinkedList* head);

#endif // UTIL_H
</util.hpp>

<readme.md>
## Problem Description

Given the head of a singly linked list, write a function to detect if the linked list contains a cycle. If a cycle is present, return true; otherwise, return false.

## Input format

The input consists of two lines. The first line contains two space-separated integers n and pos, where n is the number of nodes in the linked list and pos is the index (0-indexed) of the node where the tail connects to. The second line contains n space-separated integers, the values of the nodes in the linked list.

## Examples

### Example 1:

**Input:**
```
4 1
1 2 3 4
```

**Output:**
```
true
```

**Explanation:** The linked list has a cycle because the last node (4) points back to the node at index 1 (value 2).

---

### Example 2:

**Input:**
```
5 0
3 -3 4 0 2
```

**Output:**
```
true
```

**Explanation:** The last node (value 2) links back to the head node, forming a cycle.

---

### Example 3:

**Input:**
```
3 -1
2 0 1
```

**Output:**
```
false
```

**Explanation:** The linked list does not have a cycle, as there is no node linking back to a previous node.

---

## Constraints

- The number of nodes in the list is in the range [0, 10⁴].
- -10⁵ ≤ Node.val ≤ 10⁵
</readme.md>

<solution.md>
# Empty solution file
</solution.md>

<test.py>
class testCases:
    def __init__(self, koro_exe) -> None:
        self.RUN = 3
        self.exe = koro_exe
        self.default_timeout_window = 10
        self.usage = 'prod'
        
    def test_case_1(self, timeout_window = 5, override = 0):
        # Normal case: cycle present
        input_str = "4 1\n1 2 3 4\n"
        expected_value = "true"
        return input_str, expected_value

    def test_case_2(self, timeout_window = 5, override = 0):
        # Normal case: no cycle
        input_str = "5 -1\n1 2 3 4 5\n"
        expected_value = "false"
        return input_str, expected_value

    def test_case_3(self, timeout_window = 5, override = 0):
        # Edge case: single node with cycle
        input_str = "1 0\n1\n"
        expected_value = "true"
        return input_str, expected_value

    def test_case_4(self, timeout_window = 5, override = 0):
        # Edge case: single node without cycle
        input_str = "1 -1\n1\n"
        expected_value = "false"
        return input_str, expected_value

    def test_case_5(self, timeout_window = 5, override = 0):
        # Edge case: empty list
        input_str = "0 -1\n"
        expected_value = "false"
        return input_str, expected_value

    def test_case_6(self, timeout_window = 5, override = 0):
        # Case: cycle at the head
        input_str = "3 0\n1 2 3\n"
        expected_value = "true"
        return input_str, expected_value

    def test_case_7(self, timeout_window = 5, override = 0):
        # Case: cycle at the tail
        input_str = "4 3\n1 2 3 4\n"
        expected_value = "true"
        return input_str, expected_value

    def test_case_8(self, timeout_window = 5, override = 0):
        # Case: cycle at the middle
        input_str = "5 2\n1 2 3 4 5\n"
        expected_value = "true"
        return input_str, expected_value

    def test_case_9(self, timeout_window = 15, override = 0):  # Increased timeout_window for larger input
        # Large list (10000 nodes) with cycle
        n = 10000
        pos = 5000
        nodes = list(range(1, n + 1))
        input_str = f"{n} {pos}\n" + " ".join(map(str, nodes)) + "\n"
        expected_value = "true"
        return input_str, expected_value

    def test_case_10(self, timeout_window = 15, override = 0):  # Increased timeout_window for larger input
        # Large list (10000 nodes) without cycle
        n = 10000
        pos = -1
        nodes = list(range(1, n + 1))
        input_str = f"{n} {pos}\n" + " ".join(map(str, nodes)) + "\n"
        expected_value = "false"
        return input_str, expected_value
</test.py>

The generated code files maintain the same overall structure as the original files, with modifications to implement the new algorithm for detecting a cycle in a linked list. The majority of the code remains the same, including imports, class definitions, and helper functions. Only the algorithm-specific parts have been modified.

The `readme.md` file has been updated with the problem description, input format, and examples specific to the cycle detection algorithm. The `solution.md` file is left empty as requested.

The `test.py` file has been updated with 10 test cases covering various scenarios, including normal cases, edge cases, and large inputs. The `self.RUN` variable is set to 3 as specified.