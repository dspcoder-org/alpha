<lib.c>
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

#define VERIFY(cond)   \
    if (!(cond)) {             \
        printf("._bad_input"); \
        exit(0);               \
    }

// Content of util.h

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

struct Linked_List {
    int data;
    struct Linked_List* next;
};

// Function prototypes
extern struct Linked_List* setup_question(int argc, char* argv[]);
extern void print_LinkedList(struct Linked_List* head);

// end of util.h

struct Linked_List* buildLinkedList(int arr[], int n){
    
    struct Linked_List* head = (struct Linked_List* ) malloc(sizeof(struct Linked_List));

    if(n == 0){
        return NULL; 
    }

    struct Linked_List* dummy_head = head; 
    
    for(int i = 0; i < n ; i++){
        dummy_head->data = arr[i]; 
        if (i != n-1){
            dummy_head->next = (struct Linked_List* ) malloc(sizeof(struct Linked_List));
            dummy_head = dummy_head->next; 
        }
    }

    return head; 

}

void print_LinkedList(struct Linked_List* head){

    if(head == NULL){
        printf(""); 
    }

    while(head){
        printf("%d", head->data); 
        if(head->next){    
            printf(" "); 
        }
        head = head->next;
    }
    printf("\n"); 
}

struct Linked_List* setup_question(int argc, char* argv[]) {

    if (argc == 1) {
        int n, temp;
        
        // Input the number of elements
        VERIFY(((scanf("%d", &n)) > 0));

        // Create an array to store the node values
        int nodes[n];

        // Input the values into the array
        for (int i = 0; i < n; i++) {
            VERIFY(((scanf("%d", &nodes[i])) > 0));
        }

        VERIFY(((scanf("%d", &temp)) == EOF));

        // Build the linked list
        struct Linked_List* head =  buildLinkedList(nodes, n); 

        return head;
    } else {
        int n = atoi(argv[1]);
        int nodes[n];

        for (int i = 0; i < n; i++) {
            nodes[i] = atoi(argv[i+2]);
        }

        // Build the linked list
        struct Linked_List* head =  buildLinkedList(nodes, n);

        return head;
    }
}
</lib.c>

<main.c>
#include "util.h"
#include <stdbool.h>

bool is_palindrome(struct Linked_List* head) {
    // Write your code here
}

int main(int argc, char* argv[]) {

    // Setup the linked list
    struct Linked_List* head = setup_question(argc, argv);
    
    // User function to check if the linked list is a palindrome
    bool result = is_palindrome(head); 

    // Print the result
    printf(result ? "true\n" : "false\n");
    
    return 0;
}
</main.c>

<main_dev.c>
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

struct Linked_List {
    int data;
    struct Linked_List* next;
};

// Function prototypes
extern struct Linked_List* setup_question(int argc, char* argv[]);
extern void print_LinkedList(struct Linked_List* head);

bool is_palindrome(struct Linked_List* head) {
    if (!head || !head->next) return true;

    struct Linked_List* slow = head;
    struct Linked_List* fast = head;
    struct Linked_List* prev = NULL;
    struct Linked_List* temp;

    // Find the middle of the linked list
    while (fast && fast->next) {
        fast = fast->next->next;
        temp = slow;
        slow = slow->next;
        temp->next = prev;
        prev = temp;
    }

    // If the number of nodes is odd, skip the middle node
    if (fast) {
        slow = slow->next;
    }

    // Compare the two halves
    while (prev && slow) {
        if (prev->data != slow->data) {
            return false;
        }
        prev = prev->next;
        slow = slow->next;
    }

    return true;
}

int main(int argc, char* argv[]) {

    // Setup the linked list
    struct Linked_List* head = setup_question(argc, argv);
    
    // User function to check if the linked list is a palindrome
    bool result = is_palindrome(head); 

    // Print the result
    printf(result ? "true\n" : "false\n");
    
    return 0;
}
</main_dev.c>

<util.h>
#ifndef UTIL_H
#define UTIL_H

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

struct Linked_List {
    int data;
    struct Linked_List* next;
};

// Function prototypes
extern struct Linked_List* setup_question(int argc, char* argv[]);
extern void print_LinkedList(struct Linked_List* head);

#endif // UTIL_H
</util.h>

<lib.cpp>
#include <iostream>
#include <vector>

#define VERIFY(cond)   \
    if (!(cond)) {             \
        std::cout << "._bad_input\n"; \
        exit(0);               \
    }

// Copy content of util.hpp
class LinkedList {
public:
    int data;
    LinkedList* next;

    LinkedList(int val) : data(val), next(nullptr) {}
};

// Function declarations

LinkedList* setup_question(int argc, char* argv[]);
void print_LinkedList(LinkedList* head);

// Function to build a linked list from an array
LinkedList* buildLinkedList(int arr[], int n) {
    if (n == 0) {
        return nullptr;
    }

    LinkedList* head = new LinkedList(arr[0]);
    LinkedList* dummy_head = head;

    for (int i = 1; i < n; ++i) {
        dummy_head->next = new LinkedList(arr[i]);
        dummy_head = dummy_head->next;
    }

    return head;
}

// Function to print the linked list
void print_LinkedList(LinkedList* head) {
    if (!head) {
        return;
    }

    while (head) {
        std::cout << head->data;
        if (head->next) {
            std::cout << " ";
        }
        head = head->next;
    }
    std::cout << std::endl;
}

LinkedList* setup_question(int argc, char* argv[]) {

    if (argc == 1) {
        // Input the number of elements
        int n, temp;
        // Input the number of elements
        VERIFY((std::cin >> n));

        // Dynamically allocate an array to store the node values
        int* nodes = new int[n];

        // Input the values into the array
        for (int i = 0; i < n; i++) {
            VERIFY((std::cin >> nodes[i]));
        }
        // Check if there are any extra inputs
        // If there are, then the input is invalid
        VERIFY((std::cin >> temp).fail() == true);

        // Build the linked list
        LinkedList* head = buildLinkedList(nodes, n);

        return head;
    }
    else {
        int n = std::stoi(argv[1]);
        int* nodes = new int[n];
        for (int i = 0; i < n; i++) {
            nodes[i] = std::stoi(argv[i + 2]);
        }
        LinkedList* head = buildLinkedList(nodes, n);

        return head;
    }
}
</lib.cpp>

<main.cpp>
#include "util.hpp"
#include <vector>
#include <iostream>

bool is_palindrome(LinkedList* head) {
    // Write your code here
}

int main(int argc, char* argv[]) {
    
    // Setup the linked list
    LinkedList* head = setup_question(argc, argv);

    // Call the user function to check if the linked list is a palindrome
    bool result = is_palindrome(head);

    // Print the result
    std::cout << (result ? "true" : "false") << std::endl;

    return 0;
}
</main.cpp>

<main_dev.cpp>
#include <vector>
#include <iostream>

class LinkedList {
public:
    int data;
    LinkedList* next;

    LinkedList(int val) : data(val), next(nullptr) {}
};

// Function declarations

LinkedList* setup_question(int argc, char* argv[]);
void print_LinkedList(LinkedList* head);

bool is_palindrome(LinkedList* head) {
    if (!head || !head->next) return true;

    LinkedList* slow = head;
    LinkedList* fast = head;
    LinkedList* prev = nullptr;
    LinkedList* temp;

    // Find the middle of the linked list
    while (fast && fast->next) {
        fast = fast->next->next;
        temp = slow;
        slow = slow->next;
        temp->next = prev;
        prev = temp;
    }

    // If the number of nodes is odd, skip the middle node
    if (fast) {
        slow = slow->next;
    }

    // Compare the two halves
    while (prev && slow) {
        if (prev->data != slow->data) {
            return false;
        }
        prev = prev->next;
        slow = slow->next;
    }

    return true;
}

int main(int argc, char* argv[]) {
    
    // Setup the linked list
    LinkedList* head = setup_question(argc, argv);

    // Call the user function to check if the linked list is a palindrome
    bool result = is_palindrome(head);

    // Print the result
    std::cout << (result ? "true" : "false") << std::endl;

    return 0;
}
</main_dev.cpp>

<util.hpp>
#ifndef UTIL_H
#define UTIL_H

#include <iostream>
#include <vector>

class LinkedList {
public:
    int data;
    LinkedList* next;

    LinkedList(int val) : data(val), next(nullptr) {}
};

// Function declarations

LinkedList* setup_question(int argc, char* argv[]);
void print_LinkedList(LinkedList* head);

#endif // UTIL_H
</util.hpp>

<readme.md>
## Problem Description

Given the head of a singly linked list, write a function to check if the linked list represents a palindrome. 
A linked list is a palindrome if the sequence of values reads the same forward and backward.

## Examples

### Example 1:

**Input:**
```
5
1 2 3 2 1
```

**Output:**
```
true
```

**Explanation:**
The linked list reads the same forward and backward, making it a palindrome.

### Example 2:

**Input:**
```
4
1 2 2 1
```

**Output:**
```
true
```

**Explanation:**
The linked list is a palindrome as it is symmetric.

### Example 3:

**Input:**
```
3
1 2 3
```

**Output:**
```
false
```

**Explanation:**
The linked list is not a palindrome because 1 ≠ 3.

## Constraints:

1. The number of nodes in the list is in the range `[0, 10,000]`.
2. Each node's value satisfies `-100,000 ≤ Node.val ≤ 100,000`.
</readme.md>

<solution.md>
# Solutions will be added soon.
</solution.md>

<test.py>
class testCases:
    def __init__(self, koro_exe) -> None:
        self.RUN = 3
        self.exe = koro_exe
        self.default_timeout_window = 10
        self.usage = 'prod'
        
    def test_case_1(self, timeout_window = 5, override = 0):
        # Palindrome case: odd number of elements
        no_of_input_args = 5
        input = [1, 2, 3, 2, 1]
        numbers = f"{no_of_input_args}\n{' '.join(map(str, input))}"
        expected_value = 'true'
        return numbers, expected_value

    def test_case_2(self, timeout_window = 5, override = 0):
        # Palindrome case: even number of elements
        no_of_input_args = 4
        input = [1, 2, 2, 1]
        numbers = f"{no_of_input_args}\n{' '.join(map(str, input))}"
        expected_value = 'true'
        return numbers, expected_value

    def test_case_3(self, timeout_window = 5, override = 0):
        # Non-palindrome case
        no_of_input_args = 3
        input = [1, 2, 3]
        numbers = f"{no_of_input_args}\n{' '.join(map(str, input))}"
        expected_value = 'false'
        return numbers, expected_value

    def test_case_4(self, timeout_window = 5, override = 0):
        # Edge case: single element
        no_of_input_args = 1
        input = [42]
        numbers = f"{no_of_input_args}\n{' '.join(map(str, input))}"
        expected_value = 'true'
        return numbers, expected_value

    def test_case_5(self, timeout_window = 5, override = 0):
        # Edge case: empty list
        no_of_input_args = 0
        input = []
        numbers = f"{no_of_input_args}\n{' '.join(map(str, input))}"
        expected_value = 'true'
        return numbers, expected_value

    def test_case_6(self, timeout_window = 5, override = 0):
        # Palindrome with negative numbers
        no_of_input_args = 5
        input = [-1, -2, -3, -2, -1]
        numbers = f"{no_of_input_args}\n{' '.join(map(str, input))}"
        expected_value = 'true'
        return numbers, expected_value

    def test_case_7(self, timeout_window = 5, override = 0):
        # Non-palindrome with mixed numbers
        no_of_input_args = 6
        input = [-1, 2, -3, 3, 2, 1]
        numbers = f"{no_of_input_args}\n{' '.join(map(str, input))}"
        expected_value = 'false'
        return numbers, expected_value

    def test_case_8(self, timeout_window = 5, override = 0):
        # Palindrome with repeated numbers
        no_of_input_args = 6
        input = [1, 1, 1, 1, 1, 1]
        numbers = f"{no_of_input_args}\n{' '.join(map(str, input))}"
        expected_value = 'true'
        return numbers, expected_value

    def test_case_9(self, timeout_window = 15, override = 0):  # Increased timeout_window for larger input
        # Large palindrome list (10000 elements)
        no_of_input_args = 10000
        input = list(range(5000)) + list(range(5000)[::-1])
        numbers = f"{no_of_input_args}\n{' '.join(map(str, input))}"
        expected_value = 'true'
        return numbers, expected_value

    def test_case_10(self, timeout_window = 5, override = 0):
        # List with alternating max and min values
        no_of_input_args = 10
        input = [10000, -10000, 10000, -10000, 10000, -10000, 10000, -10000, 10000, -10000]
        numbers = f"{no_of_input_args}\n{' '.join(map(str, input))}"
        expected_value = 'false'
        return numbers, expected_value
</test.py>

<launch.json>
{
    "version": "0.2.0",
    "configurations": [
        {
            "name": "C/C++ Debug",
            "type": "cppdbg",
            "request": "launch",
            "program": "${workspaceFolder}/a.out",
            "stopAtEntry": true,
            "cwd": "${workspaceFolder}",
            "environment": [],
            "MIMode": "gdb",
            "setupCommands": [
                {
                    "description": "Enable pretty-printing for gdb",
                    "text": "-enable-pretty-printing",
                    "ignoreFailures": true
                }
            ],
            // Add debug arguments (refer test cases in dspcoder panel)
            "args": [
                "5",
                "1",
                "2",
                "3",
                "2",
                "1"
            ],
            "preLaunchTask": "build"
        }
    ]
}
</launch.json>