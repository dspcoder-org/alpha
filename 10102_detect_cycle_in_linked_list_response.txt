Here are the generated code files based on the original files, implementing the new algorithm for detecting a cycle in a linked list:

<lib.c>
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

struct Linked_List {
    int data;
    struct Linked_List* next;
};

// Function prototypes
extern struct Linked_List* setup_question();
extern void print_LinkedList(struct Linked_List* head);

struct Linked_List* buildLinkedList(int arr[], int n, int pos){
    
    struct Linked_List* head = (struct Linked_List* ) malloc(sizeof(struct Linked_List));

    if(n == 0){
        return NULL; 
    }

    struct Linked_List* dummy_head = head; 
    struct Linked_List* cycleNode = NULL;
    
    for(int i = 0; i < n ; i++){
        dummy_head->data = arr[i]; 
        if (i != n-1){
            dummy_head->next = (struct Linked_List* ) malloc(sizeof(struct Linked_List));
            dummy_head = dummy_head->next; 
        }
        if (i == pos) {
            cycleNode = dummy_head;
        }
    }

    if (pos != -1) {
        dummy_head->next = cycleNode;
    }

    return head; 

}

void print_LinkedList(struct Linked_List* head){

    if(head == NULL){
        printf(""); 
    }

    while(head){
        printf("%d", head->data); 
        if(head->next){    
            printf(" "); 
        }
        head = head->next;
    }
    printf("\n"); 
}

struct Linked_List* setup_question(){
    int n, pos;
    
    // Input the number of elements and the position of the cycle
    scanf("%d %d", &n, &pos);

    // Create an array to store the node values
    int nodes[n];

    // Input the values into the array
    for (int i = 0; i < n; i++) {
        scanf("%d", &nodes[i]);
    }

    // Build the linked list
    struct Linked_List* head =  buildLinkedList(nodes, n, pos); 

    return head;
}
</lib.c>

<main.c>
#include "../inc/util.h"

bool hasCycle(struct Linked_List* head) {
    // Write your code here
    
}

int main(){

    // Setup the linked list
    struct Linked_List* head = setup_question();
    
    // User function to detect cycle in the linked list
    bool hasCycle = hasCycle(head); 

    // Print the result
    if (hasCycle) {
        printf("true\n");
    } else {
        printf("false\n");
    }
    
    return 0;
}
</main.c>

<main_dev.c>
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

struct Linked_List {
    int data;
    struct Linked_List* next;
};

// Function prototypes
extern struct Linked_List* setup_question();
extern void print_LinkedList(struct Linked_List* head);

bool hasCycle(struct Linked_List* head) {
    // Write your code here
    struct Linked_List* slow = head;
    struct Linked_List* fast = head;

    while (fast != NULL && fast->next != NULL) {
        slow = slow->next;
        fast = fast->next->next;

        if (slow == fast) {
            return true;
        }
    }

    return false;
}

int main(){

    // Setup the linked list
    struct Linked_List* head = setup_question();
    
    // User function to detect cycle in the linked list
    bool hasCycle = hasCycle(head); 

    // Print the result
    if (hasCycle) {
        printf("true\n");
    } else {
        printf("false\n");
    }
    
    return 0;
}
</main_dev.c>

<util.h>
#ifndef UTIL_H
#define UTIL_H

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

struct Linked_List {
    int data;
    struct Linked_List* next;
};

// Function prototypes
extern struct Linked_List* setup_question();
extern void print_LinkedList(struct Linked_List* head);

#endif // UTIL_H
</util.h>

<lib.cpp>
#include <iostream>
#include <vector>

class LinkedList {
public:
    int data;
    LinkedList* next;

    LinkedList(int val) : data(val), next(nullptr) {}
};

// Function declarations

LinkedList* setup_question();
void print_LinkedList(LinkedList* head);



// Function to build a linked list from an array
LinkedList* buildLinkedList(int arr[], int n, int pos) {
    if (n == 0) {
        return nullptr;
    }

    LinkedList* head = new LinkedList(arr[0]);
    LinkedList* dummy_head = head;
    LinkedList* cycleNode = nullptr;

    for (int i = 1; i < n; ++i) {
        dummy_head->next = new LinkedList(arr[i]);
        dummy_head = dummy_head->next;

        if (i == pos) {
            cycleNode = dummy_head;
        }
    }

    if (pos != -1) {
        dummy_head->next = cycleNode;
    }

    return head;
}

// Function to print the linked list
void print_LinkedList(LinkedList* head) {
    if (!head) {
        return;
    }

    while (head) {
        std::cout << head->data;
        if (head->next) {
            std::cout << " ";
        }
        head = head->next;
    }
    std::cout << std::endl;
}

LinkedList* setup_question() {
    
    // Input the number of elements and the position of the cycle
    int n, pos;
    std::cin >> n >> pos;

    // Dynamically allocate an array to store the node values
    int* nodes = new int[n];

    // Input the values into the array
    for (int i = 0; i < n; i++) {
        std::cin >> nodes[i];
    }

    // Build the linked list
    LinkedList* head = buildLinkedList(nodes, n, pos);

    return head;
}
</lib.cpp>

<main.cpp>
#include "../inc/util.hpp"
#include <vector>
#include <iostream>

bool hasCycle(LinkedList* head) {
    // Write your code here
    
}

int main() {
    
    // Setup the linked list
    LinkedList* head = setup_question();

    // Call the user function to detect cycle in the linked list
    bool hasCycle = hasCycle(head);

    // Print the result
    if (hasCycle) {
        std::cout << "true" << std::endl;
    } else {
        std::cout << "false" << std::endl;
    }

    return 0;
}
</main.cpp>

<main_dev.cpp>
#include <vector>
#include <iostream>


class LinkedList {
public:
    int data;
    LinkedList* next;

    LinkedList(int val) : data(val), next(nullptr) {}
};

// Function declarations

LinkedList* setup_question();
void print_LinkedList(LinkedList* head);

bool hasCycle(LinkedList* head) {
    // Write your code here
    LinkedList* slow = head;
    LinkedList* fast = head;

    while (fast != nullptr && fast->next != nullptr) {
        slow = slow->next;
        fast = fast->next->next;

        if (slow == fast) {
            return true;
        }
    }

    return false;
}

int main() {
    
    // Setup the linked list
    LinkedList* head = setup_question();

    // Call the user function to detect cycle in the linked list
    bool hasCycle = hasCycle(head);

    // Print the result
    if (hasCycle) {
        std::cout << "true" << std::endl;
    } else {
        std::cout << "false" << std::endl;
    }

    return 0;
}
</main_dev.cpp>

<util.hpp>
#ifndef UTIL_H
#define UTIL_H

#include <iostream>
#include <vector>

class LinkedList {
public:
    int data;
    LinkedList* next;

    LinkedList(int val) : data(val), next(nullptr) {}
};

// Function declarations

LinkedList* setup_question();
void print_LinkedList(LinkedList* head);

#endif // UTIL_H
</util.hpp>

<readme.md>
## Problem Description

Given the head of a singly linked list, write a function to detect if the linked list contains a cycle. If a cycle is present, return true; otherwise, return false.

## Examples

### Example 1:

**Input:**
```
4 1
3 2 0 -4
```

**Output:**
```
true
```

**Explanation:** The linked list has a cycle because the last node (-4) points back to the node at index 1 (value 2).

---

### Example 2:

**Input:**
```
2 0
1 2
```

**Output:**
```
true
```

**Explanation:** The last node (value 2) links back to the head node, forming a cycle.

---

### Example 3:

**Input:**
```
1 -1
1
```

**Output:**
```
false
```

**Explanation:** The linked list does not have a cycle, as there is no node linking back to a previous node.

---

## Constraints:

1. The number of nodes in the list is in the range `[0, 10⁴]`.
2. `-10⁵ ≤ Node.val ≤ 10⁵`
3. `pos` is -1 if there is no cycle. Otherwise, it is the zero-based index of the node where the cycle starts.
</readme.md>

<solution.md>
# Empty solution file 
</solution.md>

<test.py>
class testCases:
    def __init__(self, koro_exe) -> None:
        self.RUN = 3
        self.exe = koro_exe
        self.default_timeout_window = 10
        self.usage = 'prod'
        
    def test_case_1(self, timeout_window = 5, override = 0):
        # Normal case: cycle present
        numbers = [3, 2, 0, -4]
        pos = 1
        input_str = f"{len(numbers)} {pos}\n{' '.join(map(str, numbers))}\n"
        expected_value = "true"
        return input_str, expected_value

    def test_case_2(self, timeout_window = 5, override = 0):
        # Normal case: cycle present at the head
        numbers = [1, 2]
        pos = 0
        input_str = f"{len(numbers)} {pos}\n{' '.join(map(str, numbers))}\n"
        expected_value = "true"
        return input_str, expected_value

    def test_case_3(self, timeout_window = 5, override = 0):
        # Edge case: single element, no cycle
        numbers = [1]
        pos = -1
        input_str = f"{len(numbers)} {pos}\n{' '.join(map(str, numbers))}\n"
        expected_value = "false"
        return input_str, expected_value

    def test_case_4(self, timeout_window = 5, override = 0):
        # Edge case: empty list
        numbers = []
        pos = -1
        input_str = f"{len(numbers)} {pos}\n"
        expected_value = "false"
        return input_str, expected_value

    def test_case_5(self, timeout_window = 5, override = 0):
        # Edge case: cycle at the last node
        numbers = [1, 2, 3, 4, 5]
        pos = 4
        input_str = f"{len(numbers)} {pos}\n{' '.join(map(str, numbers))}\n"
        expected_value = "true"
        return input_str, expected_value

    def test_case_6(self, timeout_window = 5, override = 0):
        # Case with negative numbers, no cycle
        numbers = [-1, -2, -3, -4, -5]
        pos = -1
        input_str = f"{len(numbers)} {pos}\n{' '.join(map(str, numbers))}\n"
        expected_value = "false"
        return input_str, expected_value

    def test_case_7(self, timeout_window = 5, override = 0):
        # Case with mixed positive and negative numbers, cycle present
        numbers = [-10000, 0, 5555, -9999, 2222, -1111, 10000]
        pos = 3
        input_str = f"{len(numbers)} {pos}\n{' '.join(map(str, numbers))}\n"
        expected_value = "true"
        return input_str, expected_value

    def test_case_8(self, timeout_window = 5, override = 0):
        # Case with repeated numbers, cycle present
        numbers = [9999, 9999, -9999, -9999, 0, 0]
        pos = 2
        input_str = f"{len(numbers)} {pos}\n{' '.join(map(str, numbers))}\n"
        expected_value = "true"
        return input_str, expected_value

    def test_case_9(self, timeout_window = 15, override = 0):  # Increased timeout_window for larger input
        # Large list (10000 elements), no cycle
        numbers = list(range(-5000, 5000))
        pos = -1
        input_str = f"{len(numbers)} {pos}\n{' '.join(map(str, numbers))}\n"
        expected_value = "false"
        return input_str, expected_value

    def test_case_10(self, timeout_window = 5, override = 0):
        # List with alternating max and min values, cycle present
        numbers = [10000, -10000] * 5
        pos = 5
        input_str = f"{len(numbers)} {pos}\n{' '.join(map(str, numbers))}\n"
        expected_value = "true"
        return input_str, expected_value
</test.py>